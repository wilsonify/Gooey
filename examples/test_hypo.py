"""
How do I use pytest fixtures with Hypothesis?

based on faq python technical post by David R. MacIver Tuesday, August 09, 2016

pytest is a great test runner, and is the one Hypothesis itself uses for testing
(though Hypothesis works fine with other test runners too).
It has a fairly elaborate fixture system, and people are often unsure how that interacts with Hypothesis.

Mostly, Hypothesis and py.test fixtures don’t interact: Each just ignores the other’s presence.
When using a @given decorator,
any arguments that are not provided in the @given will be left visible in the final function:
"""

import pytest
from hypothesis import given, strategies
from inspect import getfullargspec


@pytest.fixture(name='b', scope="session")
def b_fixture():
    """
    fixture, is reset between function calls but not between test cases generated by `@given(...)`.
    here we set session-scoped fixture because it is safe to reuse;
    alternatively we could using a context manager (with clause) inside each test function.
    """
    return "b"


@pytest.fixture(name='d', scope="session")
def d_fixture():
    return "d"


@pytest.fixture(name='stuff', scope="session")
def stuff_fixture():
    return "kittens"


@given(a=strategies.none(), c=strategies.none())
def test_smoke(a, b, c, d):
    """
    This then outputs the following:
    ArgSpec(args=['b', 'd'], varargs=None, keywords=None, defaults=None)
    We’ve hidden the arguments ‘a’ and ‘c’, but the unspecified arguments ‘b’ and ‘d’ are still left to be passed in.
    In particular, they can be provided as py.test fixtures:
    """
    print(f"a={a}")
    print(f"b={b}")
    print(f"c={c}")
    print(f"d={d}")
    print(getfullargspec(test_smoke))


@given(a=strategies.none())
def test_named_a_stuff(a, stuff):
    assert a is None
    assert stuff == "kittens"


@given(strategies.none())
def test_positional_a_stuff(stuff, a):
    """
    This also works if we want to use @given with positional arguments:
    The positional argument fills in from the right,
    replacing the ‘a’ argument and leaving us with ‘stuff’ to be provided by the fixture.
    Personally I don’t usually do this because I find it gets a bit confusing -
    if I’m going to use fixtures then I always use the named variant of given.
    There’s no reason you can’t do it this way if you prefer though.
    @given also works fine in combination with parametrized tests:
    """
    assert a is None
    assert stuff == "kittens"


@pytest.mark.parametrize(
    'param', [1, 2, 3]
)
@given(a=strategies.none())
def test_stuff_parametrized(a, param):
    """
    This will run 3 tests, one for each value for ‘stuff’.
    There is one unfortunate feature of how this interaction works though: In pytest you can declare fixtures which do set up and tear down per function. These will “work” with Hypothesis, but they will run once for the entire test function rather than once for each time given calls your test function. So the following will fail:
    """
    assert a is None
    assert 1 <= param <= 3


def string_stripper(a_str: str) -> str:
    """
    remove 1 or more non-alphanumeric characters from a string
    """
    if a_str is None:
        return ""
    if a_str == "":
        return ""
    import re
    return re.sub(pattern=r"\W+", repl="", string=a_str, count=0, flags=0)


@given(a=strategies.text())
def test_string_stripper(a):
    """
    fuzz test string_stripper
    """
    assert type(a) == str
    print(f"a={a}")

    result = string_stripper(a)
    print(f"result={result}")

    assert type(result) == str
    assert len(result) <= len(a)
